#!/bin/bash
# Bash Dialect Processor for Echo Forge-AI Integrity
# Handles system-level verification and Unix/Linux security checks
# Lineage: RepoReportEcho_092425

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_DIR="${1:-$(dirname "$SCRIPT_DIR")/../..}"
LINEAGE_ID="RepoReportEcho_092425"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    local level="$1"
    shift
    echo -e "[${TIMESTAMP}] [${level}] $*" >&2
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }

# Generate checksum for file
generate_checksum() {
    local file="$1"
    local algorithm="${2:-sha256}"
    
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        return 1
    fi
    
    case "$algorithm" in
        sha256)
            if command -v sha256sum >/dev/null 2>&1; then
                sha256sum "$file" | cut -d' ' -f1
            elif command -v shasum >/dev/null 2>&1; then
                shasum -a 256 "$file" | cut -d' ' -f1
            else
                log_error "No SHA-256 utility available"
                return 1
            fi
            ;;
        md5)
            if command -v md5sum >/dev/null 2>&1; then
                md5sum "$file" | cut -d' ' -f1
            elif command -v md5 >/dev/null 2>&1; then
                md5 -q "$file"
            else
                log_error "No MD5 utility available"
                return 1
            fi
            ;;
        *)
            log_error "Unsupported hash algorithm: $algorithm"
            return 1
            ;;
    esac
}

# Verify system security configuration
check_system_security() {
    local report_file="$1"
    log_info "Performing system security checks"
    
    {
        echo "# System Security Report - $LINEAGE_ID"
        echo "Generated: $TIMESTAMP"
        echo "Host: $(hostname)"
        echo "OS: $(uname -a)"
        echo ""
        
        echo "## File System Security"
        # Check for world-writable files in common directories
        if [[ -d "/tmp" ]]; then
            echo "### World-writable files in /tmp:"
            find /tmp -type f -perm -002 2>/dev/null | head -10 || echo "None found or access denied"
        fi
        
        echo ""
        echo "## Process Security"
        echo "### Running processes (top 10 by CPU):"
        ps aux --sort=-%cpu | head -11 2>/dev/null || echo "Process list unavailable"
        
        echo ""
        echo "## Network Security"
        echo "### Open network connections:"
        if command -v netstat >/dev/null 2>&1; then
            netstat -tuln 2>/dev/null | head -20 || echo "Network information unavailable"
        elif command -v ss >/dev/null 2>&1; then
            ss -tuln 2>/dev/null | head -20 || echo "Network information unavailable"
        else
            echo "No network utilities available"
        fi
        
        echo ""
        echo "## System Resource Usage"
        echo "### Disk usage:"
        df -h 2>/dev/null | head -10 || echo "Disk information unavailable"
        
        echo ""
        echo "### Memory usage:"
        if [[ -f "/proc/meminfo" ]]; then
            grep -E "MemTotal|MemFree|MemAvailable" /proc/meminfo 2>/dev/null || echo "Memory information unavailable"
        else
            echo "Memory information unavailable"
        fi
        
        echo ""
        echo "## Security Configuration"
        echo "### Firewall status:"
        if command -v ufw >/dev/null 2>&1; then
            ufw status 2>/dev/null || echo "UFW status unavailable"
        elif command -v iptables >/dev/null 2>&1; then
            echo "iptables rules count: $(iptables -L 2>/dev/null | wc -l || echo "0")"
        else
            echo "No firewall utilities available"
        fi
        
        echo ""
        echo "---"
        echo "Report generated by Bash Dialect Processor"
        echo "Lineage: $LINEAGE_ID"
        
    } > "$report_file"
    
    log_info "System security report generated: $report_file"
}

# Verify CVE manifest files using bash utilities
verify_cve_manifests() {
    local cve_dir="$BASE_DIR/data/cve"
    local output_file="$BASE_DIR/reports/bash/cve_verification_$(date +%Y%m%d_%H%M%S).txt"
    
    mkdir -p "$(dirname "$output_file")"
    
    log_info "Verifying CVE manifests in: $cve_dir"
    
    {
        echo "# Bash CVE Manifest Verification Report - $LINEAGE_ID"
        echo "Generated: $TIMESTAMP"
        echo "Source Directory: $cve_dir"
        echo ""
        
        if [[ ! -d "$cve_dir" ]]; then
            echo "ERROR: CVE directory not found: $cve_dir"
            log_error "CVE directory not found: $cve_dir"
            return 1
        fi
        
        local json_files
        mapfile -t json_files < <(find "$cve_dir" -name "*.json" -type f 2>/dev/null)
        
        if [[ ${#json_files[@]} -eq 0 ]]; then
            echo "WARNING: No JSON files found in $cve_dir"
            log_warn "No JSON files found in $cve_dir"
            return 0
        fi
        
        echo "Found ${#json_files[@]} JSON files to verify"
        echo ""
        
        local valid_count=0
        local invalid_count=0
        
        for json_file in "${json_files[@]}"; do
            echo "## Verifying: $(basename "$json_file")"
            echo "File path: $json_file"
            
            # Check if file is readable
            if [[ ! -r "$json_file" ]]; then
                echo "❌ ERROR: File not readable"
                ((invalid_count++))
                continue
            fi
            
            # Get file size
            local file_size
            file_size=$(stat -c%s "$json_file" 2>/dev/null || echo "unknown")
            echo "File size: $file_size bytes"
            
            # Generate checksum
            local checksum
            checksum=$(generate_checksum "$json_file" sha256)
            echo "SHA-256: $checksum"
            
            # Basic JSON validation using python if available
            if command -v python3 >/dev/null 2>&1; then
                if python3 -c "import json; json.load(open('$json_file'))" 2>/dev/null; then
                    echo "✅ JSON format: VALID"
                    
                    # Extract key fields using basic text processing
                    local cve_id
                    cve_id=$(grep -o '"cve_id"[[:space:]]*:[[:space:]]*"[^"]*"' "$json_file" | sed 's/.*"cve_id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "UNKNOWN")
                    echo "CVE ID: $cve_id"
                    
                    local severity
                    severity=$(grep -o '"severity"[[:space:]]*:[[:space:]]*"[^"]*"' "$json_file" | sed 's/.*"severity"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "UNKNOWN")
                    echo "Severity: $severity"
                    
                    # Check for required fields
                    local required_fields=("cve_id" "description" "severity" "published_date")
                    local missing_fields=()
                    
                    for field in "${required_fields[@]}"; do
                        if ! grep -q "\"$field\"" "$json_file"; then
                            missing_fields+=("$field")
                        fi
                    done
                    
                    if [[ ${#missing_fields[@]} -eq 0 ]]; then
                        echo "✅ Required fields: COMPLETE"
                        echo "Overall status: ✅ VALID"
                        ((valid_count++))
                    else
                        echo "❌ Missing fields: ${missing_fields[*]}"
                        echo "Overall status: ❌ INVALID"
                        ((invalid_count++))
                    fi
                else
                    echo "❌ JSON format: INVALID"
                    echo "Overall status: ❌ INVALID"
                    ((invalid_count++))
                fi
            else
                echo "⚠️  JSON validation: SKIPPED (no python3 available)"
                echo "Overall status: ⚠️  PARTIAL"
                ((valid_count++))
            fi
            
            echo ""
        done
        
        echo "## Summary"
        echo "Total files processed: ${#json_files[@]}"
        echo "Valid manifests: $valid_count"
        echo "Invalid manifests: $invalid_count"
        
        local success_rate=0
        if [[ ${#json_files[@]} -gt 0 ]]; then
            success_rate=$((valid_count * 100 / ${#json_files[@]}))
        fi
        echo "Success rate: ${success_rate}%"
        
        echo ""
        echo "---"
        echo "Verification completed by Bash Dialect Processor"
        echo "Lineage: $LINEAGE_ID"
        echo "Report checksum: $(generate_checksum "$output_file" sha256 2>/dev/null || echo "pending")"
        
    } > "$output_file"
    
    # Generate checksum file
    local checksum_file="${output_file}.sha256"
    generate_checksum "$output_file" sha256 > "$checksum_file"
    
    log_info "CVE verification report generated: $output_file"
    log_info "Report checksum: $(cat "$checksum_file")"
    
    echo "$output_file"
}

# Create system monitoring script
create_monitoring_script() {
    local script_path="$BASE_DIR/dialects/bash/system_monitor.sh"
    log_info "Creating system monitoring script: $script_path"
    
    cat > "$script_path" << 'EOF'
#!/bin/bash
# System Monitoring Script for Echo Forge-AI Integrity
# Monitors system resources and security events
# Lineage: RepoReportEcho_092425

set -euo pipefail

LINEAGE_ID="RepoReportEcho_092425"
MONITOR_INTERVAL="${1:-60}"  # seconds
LOG_FILE="${2:-system_monitor.log}"

log_with_timestamp() {
    echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] $*" >> "$LOG_FILE"
}

monitor_system() {
    log_with_timestamp "=== System Monitor Start - $LINEAGE_ID ==="
    
    # CPU usage
    if command -v top >/dev/null 2>&1; then
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 2>/dev/null || echo "N/A")
        log_with_timestamp "CPU Usage: ${cpu_usage}%"
    fi
    
    # Memory usage
    if [[ -f "/proc/meminfo" ]]; then
        mem_total=$(grep "MemTotal:" /proc/meminfo | awk '{print $2}' 2>/dev/null || echo "0")
        mem_available=$(grep "MemAvailable:" /proc/meminfo | awk '{print $2}' 2>/dev/null || echo "0")
        if [[ "$mem_total" -gt 0 ]]; then
            mem_usage=$((100 - (mem_available * 100 / mem_total)))
            log_with_timestamp "Memory Usage: ${mem_usage}%"
        fi
    fi
    
    # Disk usage
    disk_usage=$(df / | awk 'NR==2 {print $5}' | tr -d '%' 2>/dev/null || echo "N/A")
    log_with_timestamp "Disk Usage: ${disk_usage}%"
    
    # Load average
    if [[ -f "/proc/loadavg" ]]; then
        load_avg=$(cut -d' ' -f1-3 /proc/loadavg 2>/dev/null || echo "N/A")
        log_with_timestamp "Load Average: $load_avg"
    fi
    
    log_with_timestamp "=== System Monitor End ==="
}

# Run monitoring
while true; do
    monitor_system
    sleep "$MONITOR_INTERVAL"
done
EOF
    
    chmod +x "$script_path"
    log_info "System monitoring script created and made executable"
}

# Main execution function
main() {
    log_info "Starting Bash Dialect Processor"
    log_info "Base directory: $BASE_DIR"
    log_info "Lineage ID: $LINEAGE_ID"
    
    # Create output directories
    mkdir -p "$BASE_DIR/reports/bash"
    
    # Run system security check
    local security_report="$BASE_DIR/reports/bash/system_security_$(date +%Y%m%d_%H%M%S).md"
    check_system_security "$security_report"
    
    # Verify CVE manifests
    local cve_report
    cve_report=$(verify_cve_manifests)
    
    # Create monitoring script
    create_monitoring_script
    
    # Generate summary
    local summary_file="$BASE_DIR/reports/bash/bash_processor_summary_$(date +%Y%m%d_%H%M%S).txt"
    {
        echo "# Bash Dialect Processor Summary - $LINEAGE_ID"
        echo "Generated: $TIMESTAMP"
        echo ""
        echo "## Generated Reports:"
        echo "- System Security Report: $security_report"
        echo "- CVE Verification Report: $cve_report"
        echo "- System Monitor Script: $BASE_DIR/dialects/bash/system_monitor.sh"
        echo ""
        echo "## Report Checksums:"
        echo "- Security Report: $(generate_checksum "$security_report" sha256 2>/dev/null || echo "pending")"
        echo "- CVE Report: $(generate_checksum "$cve_report" sha256 2>/dev/null || echo "pending")"
        echo ""
        echo "Processing completed successfully by Bash Dialect Processor"
        echo "Lineage: $LINEAGE_ID"
    } > "$summary_file"
    
    log_info "Bash dialect processing completed"
    log_info "Summary report: $summary_file"
    
    # Output results
    echo "Bash Dialect Processor completed successfully"
    echo "Security Report: $security_report"
    echo "CVE Report: $cve_report"
    echo "Summary: $summary_file"
}

# Run main function if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi